diff --git a/frontend/drivers/platform_unix.c b/frontend/drivers/platform_unix.c
index 4f30d6db69..e4fa40cd2e 100644
--- a/frontend/drivers/platform_unix.c
+++ b/frontend/drivers/platform_unix.c
@@ -27,6 +27,14 @@
 #include <sys/utsname.h>
 #include <sys/resource.h>
 
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <unistd.h>
+
 #ifdef __linux__
 #include <linux/version.h>
 #if __STDC_VERSION__ >= 199901L && !defined(ANDROID)
@@ -935,6 +943,68 @@ static bool int_string(char *str, int *val)
    return ((*str != '\0') && (*endptr == '\0'));
 }
 
+// Structure sent by cs-hud
+#pragma pack(push, 1)
+struct Payload {
+   // is the device plugged in?
+   bool plugged;
+   // is the device charging?
+   bool charging;
+   // battery percentage
+   uint8_t percent;
+};
+#pragma pack(pop)
+
+static bool frontend_unix_powerstate_check_cs_hud(
+      enum frontend_powerstate *state,
+      int *percent)
+{
+   char *socket_path = getenv("CS_HUD_SOCKET");
+   if (!socket_path) {
+      RARCH_ERR("[cs-hud]: CS_HUD_SOCKET not set\n");
+      return false;
+   }
+   int sock_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+   if (sock_fd < 0) {
+      RARCH_ERR("[cs-hud]: socket failed\n");
+      return false;
+   }
+
+   struct sockaddr_un addr = {0};
+   addr.sun_family = AF_UNIX;
+   strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path) - 1);
+
+   if (connect(sock_fd, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) < 0) {
+      RARCH_ERR("[cs-hud]: connect failed\n");
+      close(sock_fd);
+      return false;
+   }
+
+   struct Payload payload;
+   ssize_t n = recv(sock_fd, &payload, sizeof(payload), 0);
+   if (n == sizeof(payload)) {
+      RARCH_LOG("[cs-hud]: plugged: %d\n", payload.plugged);
+      RARCH_LOG("[cs-hud]: charging: %d\n", payload.charging);
+      RARCH_LOG("[cs-hud]: percent: %d\n", payload.percent);
+   } else {
+      RARCH_ERR("[cs-hud]: recv failed or incomplete: %zd bytes\n", n);
+      close(sock_fd);
+      return false;
+   }
+
+   close(sock_fd);
+
+   *percent = (int)payload.percent;
+   if (payload.charging)
+      *state = FRONTEND_POWERSTATE_CHARGING;
+   else if (payload.plugged)
+      *state = FRONTEND_POWERSTATE_CHARGED;
+   else
+      *state = FRONTEND_POWERSTATE_ON_POWER_SOURCE;
+
+   return true;
+}
+
 static bool frontend_unix_powerstate_check_apm(
       enum frontend_powerstate *state,
       int *seconds, int *percent)
@@ -1192,6 +1262,9 @@ static enum frontend_powerstate frontend_unix_get_powerstate(
    /* 'Time left' reporting is unsupported */
    *seconds = -1;
 #else
+   if (frontend_unix_powerstate_check_cs_hud(&ret, percent))
+      return ret;
+
    if (frontend_unix_powerstate_check_acpi_sysfs(&ret, seconds, percent))
       return ret;
 
